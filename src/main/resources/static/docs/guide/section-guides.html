<!DOCTYPE html>
<html lang="">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.18">
<title>Untitled</title>
<link rel="stylesheet" href="styles/custom.css">
</head>
<body class="article">
<div id="header">
</div>
<div id="content">
<div class="paragraph">
<p>Section guide blocks for index.adoc
Usage: include::guide/section-guides.adoc[tag=&lt;tagname&gt;]</p>
</div>
<div class="paragraph">
<p>tag::users[]</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p><strong>Users API 권장 흐름(클라이언트 기준)</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>회원가입 → 로그인(쿠키 권장)</p>
</li>
<li>
<p>사용자 검색은 Cursor 기반이므로, 응답의 <code>nextCursor</code>(또는 유사 필드)를 저장했다가 다음 페이지 요청에 사용합니다.</p>
</li>
<li>
<p>목록 UI에서 <code>isFollowing</code> 같은 플래그가 있으면 “팔로우/언팔로우” 버튼 상태를 즉시 결정할 수 있습니다.</p>
</li>
</ol>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>end::users[]</p>
</div>
<div class="paragraph">
<p>tag::files[]</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p><strong>Files API 캐시/ETag 가이드</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>다운로드/썸네일은 ETag(304)를 활용하면 트래픽을 크게 줄일 수 있습니다.</p>
</li>
<li>
<p>브라우저는 동일 URL에 대해 캐시를 사용할 수 있으니, 파일 변경 정책이 있으면 URL 버저닝/쿼리스트링 전략을 고려하세요.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>end::files[]</p>
</div>
<div class="paragraph">
<p>tag::follows[]</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p><strong>Follows API 권장 흐름</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>검색/프로필 화면에서 `isFollowing`을 기반으로 버튼 상태를 결정합니다.</p>
</li>
<li>
<p>“자기 자신 팔로우(400)” 같은 실패 케이스는 UI에서 미리 막는 것이 UX에 좋습니다.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>end::follows[]</p>
</div>
<div class="paragraph">
<p>tag::posts[]</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p><strong>Posts API 권장 흐름</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>작성(텍스트 + 첨부 파일이 있다면 Files 업로드 후 fileId 참조)</p>
</li>
<li>
<p>단건 조회로 상세 화면 구성</p>
</li>
<li>
<p>삭제 후 목록/피드 재조회 또는 로컬에서 제거 처리</p>
</li>
</ol>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>end::posts[]</p>
</div>
<div class="paragraph">
<p>tag::postlikes[]</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p><strong>Post Likes UX 팁</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>좋아요는 UI에서 낙관적 업데이트(optimistic update)로 처리하고,
실패 시 롤백하는 패턴이 가장 자연스럽습니다.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>end::postlikes[]</p>
</div>
<div class="paragraph">
<p>tag::notifications[]</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p><strong>Notifications 권장 흐름</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>목록 조회 → 읽음 처리 → 전체 읽음/삭제는 “상태 동기화” 성격입니다.</p>
</li>
<li>
<p>SSE 이벤트로 새 알림을 감지한 뒤, 화면에서는 알림 목록 API를 재조회하는 패턴을 권장합니다.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>end::notifications[]</p>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 0.0.1-SNAPSHOT<br>
Last updated 2026-02-20 13:14:55 +0900
</div>
</div>
</body>
</html>